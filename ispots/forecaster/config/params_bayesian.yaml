LinearTrend:
  alpha: hp.loguniform('alpha_linearTrend', np.log(0.001), np.log(10))
  trend_order: hp.quniform('trend_order_linearTrend', 1, 4, 1)
Hybrid:
  stage1: hp.choice('stage1_hybrid', ['Linear', 'Prophet'])
  stage2: hp.choice('stage2_hybrid', ['Linear', 'LGB', 'XGB', 'Sarimax', 'LSTM'])
Linear:
  alpha: hp.loguniform('alpha_linear', np.log(0.001), np.log(10))
  cyclic_feature_encoding: hp.choice('cyclic_feature_encoding_linear', ['sincos', 'onehot'])
Prophet:
  growth: hp.choice('growth_prophet', ['linear', 'logistic'])
  seasonality_mode: hp.choice('seasonality_mode_prophet', ['additive', 'multiplicative'])
  cyclic_feature_encoding: hp.choice('cyclic_feature_encoding_prophet', ['sincos', 'onehot'])
  n_changepoints: hp.quniform('n_changepoints_prophet', 5, 50, 1)
  changepoint_range: hp.uniform('changepoint_range_prophet', 0.5, 0.9)
  seasonality_prior_scale: hp.loguniform('seasonality_prior_scale_prophet', np.log(0.01), np.log(10)) 
  changepoint_prior_scale: hp.loguniform('changepoint_prior_scale_prophet', np.log(0.01), np.log(10))
LGB:
  learning_rate: hp.loguniform('learning_rate_lgb', np.log(0.01), np.log(0.99))
  max_depth: hp.quniform('max_depth_lgb', 1, 10, 1)
  min_child_weight: hp.quniform('min_child_weight_lgb', 1, 10, 1)
  boosting: hp.choice('boosting_lgb', ['gbdt', 'dart'])
  min_gain_to_split: hp.uniform('min_gain_to_split_lgb', 0, 10)
  num_leaves: hp.quniform('num_leaves_lgb', 10, 300, 10)
  subsample: hp.uniform('subsample_lgb', 0.5, 0.9)
  colsample_bytree: hp.uniform('colsample_bytree_lgb', 0.5, 0.9) 
  colsample_bynode: hp.uniform('colsample_bynode_lgb', 0.5, 0.9)
  reg_lambda: hp.uniform('reg_lambda_lgb', 0, 1)
  reg_alpha: hp.quniform('reg_alpha_lgb', 0, 100, 1)
  cyclic_feature_encoding: hp.choice('cyclic_feature_encoding_lgb', ['sincos', 'onehot'])
XGB:
  learning_rate: hp.loguniform('learning_rate_xgb', np.log(0.01), np.log(0.99))
  max_depth: hp.quniform('max_depth_xgb', 1, 10, 1)
  min_child_weight: hp.quniform('min_child_weight_xgb', 1, 10, 1)
  booster: hp.choice('booster_xgb', ['gbtree', 'dart'])
  min_split_loss: hp.uniform('min_split_loss_xgb', 0, 10) 
  subsample: hp.uniform('subsample_xgb', 0.5, 0.9)
  colsample_bytree: hp.uniform('colsample_bytree_xgb', 0.5, 0.9)
  colsample_bylevel: hp.uniform('colsample_bylevel_xgb', 0.5, 0.9)
  colsample_bynode: hp.uniform('colsample_bynode_xgb', 0.5, 0.9)
  reg_lambda: hp.uniform('reg_lambda_xgb', 0, 1)
  reg_alpha: hp.quniform('reg_alpha_xgb', 0, 100, 1)
  cyclic_feature_encoding: hp.choice('cyclic_feature_encoding_xgb', ['sincos', 'onehot'])
Sarimax:
  p: hp.quniform('p_sarimax', 0, 10, 1)
  d: hp.quniform('d_sarimax', 0, 10, 1)
  q: hp.quniform('q_sarimax', 0, 10, 1)
  seasonal_p: hp.quniform('seasonal_p_sarimax', 0, 10, 1)
  seasonal_d: hp.quniform('seasonal_d_sarimax', 0, 10, 1)
  seasonal_q: hp.quniform('seasonal_q_sarimax', 0, 10, 1)
  cyclic_feature_encoding: hp.choice('cyclic_feature_encoding_sarimax', ['sincos', 'onehot'])
LSTM:
  lr: hp.uniform('lr_lstm', 0.001, 0.01)
  batch_size: hp.choice('batch_size_lstm', [64, 128, 256])
  lstm_units: hp.quniform('lstm_units_lstm', 50, 200, 10)
  lstm_layers: hp.quniform('lstm_layers_lstm', 1, 4, 1)
  dense_units: hp.quniform('dense_units_lstm', 50, 200, 10)
  dense_layers: hp.quniform('dense_layers_lstm', 1, 4, 1)
  cyclic_feature_encoding: hp.choice('cyclic_feature_encoding_lstm', ['sincos', 'onehot'])
  type: hp.choice('type_lstm', ['vanilla', 'encoder-decoder'])
  stateful: hp.choice('stateful_lstm', [True, False])
  factor: hp.uniform('factor_lstm', 0.5, 0.9)